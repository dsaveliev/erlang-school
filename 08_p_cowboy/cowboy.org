* Веб-сервер cowboy

Это не веб фреймворк, это веб сервер. Функциональность у него минималистичная.

https://github.com/extend/cowboy

http://ninenines.eu/docs/en/cowboy/HEAD/guide/


** роутинг

http://ninenines.eu/docs/en/cowboy/HEAD/guide/routing/

Роутинг имеет довольно громоздкий синтаксис.
Ковбой анализирует URI запроса, и, учитывая хост и путь к ресурсу,
выбирает обработчик.

Routes = [Host1, Host2, ... HostN]
где Host, это
{HostMatch, PathsList}
где PathList это
[Path1, Path2, ... PathN]
где Path это
{PathMatch, Handler, Opts}

лучше сразу взять конкретный пример:

#+BEGIN_SRC Erlang
    Routing =
        [{'_',                        % any host
          [                           % path list
           {"/api/chat/",             % path match
            bullet_handler,           % handler
            [{handler, chat_handler}] % options
           },
           {"/",
            cowboy_static,
            {file, "priv/static/index.html", [{mimetypes, cow_mimetypes, all}]}},
           {"/[...]",
            cowboy_static,
            {dir, "priv/static", [{mimetypes, cow_mimetypes, all}]}},
           {'_',
            not_found_handler,
            []}
          ]}],
#+END_SRC

Биндинги:
#+BEGIN_SRC Erlang
/user/:id/profile/ % /user/77/profile, /user/42/profile

{Id, Req2} = cowboy_req:binding(id, Req) % <<"77">>, <<"42">>
#+END_SRC

Необязательные сегменты:
#+BEGIN_SRC Erlang
/posts/[page/:number] % /posts, /posts/page/2
#+END_SRC

Эти Routing нужно скомпилировать, чтобы получить эффективное по
производительности внутреннее представление:
#+BEGIN_SRC Erlang
Routing2 = cowboy_router:compile(Routing)
#+END_SRC

И потом можно запускать ковбой:
#+BEGIN_SRC Erlang
cowboy:start_http(http, 100,
                  [{port, 8080}],
                  [{env, [{dispatch, Routing2}]}])
#+END_SRC

Здесь мы запускаем ковбой для обработки http запросов (для https нужно запускать отдельно),
с пулом из 100 акцепторов соединений, на порту 8080, с заданным роутингом.

Роутинг можно изменить, не останавливая сервер:
#+BEGIN_SRC Erlang
Routing2 = cowboy_router:compile(NewRouting),
cowboy:set_env(my_http_listener, dispatch, Rounting2).
#+END_SRC


** статические файлы

Для статического контента используется хендлер cowboy_static

В Options ему можно указать конкретный файл:
#+BEGIN_SRC Erlang
{"/",
 cowboy_static,
 {file, "priv/static/index.html", [{mimetypes, cow_mimetypes, all}]}},
#+END_SRC

Либо можно указать каталог:
#+BEGIN_SRC Erlang
{"/static/[...]",
 cowboy_static,
 {dir, "priv/static", [{mimetypes, cow_mimetypes, all}]}},
#+END_SRC
Здесь для всех путей вида http://host/static/bla/bla/bla
будет отдаваться файл priv/static/bla/bla/bla.


** http хендлер

#+BEGIN_SRC Erlang
{"/user/:user_id/profile/", sample_http_handler, []},
{'_', not_found_handler, []}
#+END_SRC

src/not_found_handler

src/sample_http_handler

POST данные можно увидеть, отправив запрос с помощью curl
#+BEGIN_SRC Erlang
yura ~ $ curl "http://localhost:8080/user/88/profile" \
> -d "user_name=Bill&age=33"

<h1>Sample http handler</h1>
<p>Host: localhost</p>
<p>Path: /user/88/profile</p>
<p>Url: http://localhost:8080/user/88/profile</p>
<p>QueryString: </p>
<p>Get Params: <ul></ul></p>
<p>Post Params: <ul><li>user_name:Bill</li><li>age:33</li></ul></p>
<p>User Id: 88</p>
<p>User Name: guest</p>%
#+END_SRC


** erlydtl шаблоны

Быстрые, компилируются в эрланговский модуль (beam-файл),
загружаются на старте ноды и хранятся в оперативной памяти а не читаются с диска
при каждом запросе.

https://github.com/erlydtl/erlydtl/

Проще всего их собирать ребаром. Для этого в rebar.config добавить:
#+BEGIN_SRC Erlang
{erlydtl_opts, [
                {doc_root, "priv/templates"}
]}.
{deps, [
       ...
        {erlydtl, ".*", {git, "https://github.com/erlydtl/erlydtl", "0.9.4"}}
       ]}.
#+END_SRC

Тогда при сборке из файла priv/templates/sample.dtl получается ebin/sample_dtl.beam

Чтобы подставить данные в шаблон, нужно:
#+BEGIN_SRC Erlang
{ok, Body} = sample_dtl:render([{name, UserName},
                                {email, <<"some@where.com">>},
                                {city, <<"Minsk">>},
                                {messages, [{1, "Message 1"},
                                            {2, "Message 2"},
                                            {3, "Message 3"}]}])
#+END_SRC

Если шаблон изменился, и его хочется подгрузить, не останавливая сервер,
это делается, как с любым эрланговским модулем: сперва перекомпилировать
#+BEGIN_SRC Erlang
rebat compile
#+END_SRC
затем подгрузить
#+BEGIN_SRC Erlang
l(sample_dtl).
#+END_SRC

Или использовать sync, обеспечивающий автоматическую загрузку измененных модулей.


** поддержка сессий

#+BEGIN_SRC Erlang
#+END_SRC


** web socket хендлер (и bullet.js клиент)

#+BEGIN_SRC Erlang
#+END_SRC
